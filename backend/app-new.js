require('dotenv').config();
const express = require('express');
const cors = require('cors');
const session = require('express-session');
const SQLiteStore = require('connect-sqlite3')(session);

// Middleware
const { globalErrorHandler, notFoundHandler } = require('./middleware/errorHandler');
const userContextMiddleware = require('./middleware/userContextMiddleware');

// Routes
const productsRouter = require('./routes/products');
const clientRoutes = require('./routes/client-routes');
const orderRoutes = require('./routes/order-routes');
const productionRoutes = require('./routes/production-routes');
const writeoffRoutes = require('./routes/writeoff-routes');
const movementRoutes = require('./routes/movement-routes');
const orderDocxRouter = require('./routes/order-docx');
const { router: orderPdfRouter, initPdfRoutes } = require('./routes/order-pdf');
const batchRoutes = require('./routes/batch-routes');
const newWriteoffRoutes = require('./routes/new-writeoff-routes');
const arrivalRoutes = require('./routes/arrival-routes');  
const operationsLogRoutes = require('./routes/operations-log-routes');
const authRoutes = require('./routes/auth-routes');
const userRoutes = require('./routes/user-routes');

// Services
const productService = require('./services/productService');
const clientService = require('./services/clientService');
const orderService = require('./services/orderService');
const productionService = require('./services/productionService');
const writeoffService = require('./services/writeoffService');
const movementService = require('./services/movementService');
const arrivalService = require('./services/arrivalService');
const authService = require('./services/authService');
const permissionService = require('./services/permissionService');
const userService = require('./services/userService');

const app = express();
const PORT = 3000;

// ================================
// MIDDLEWARE SETUP
// ================================
app.use(cors());
app.use(express.json());
app.use(express.static('./frontend'));

// Debug middleware - ะปะพะณัะฒะฐะฝะฝั ะฒััั ะทะฐะฟะธััะฒ
app.use((req, res, next) => {
    const fs = require('fs');
    fs.appendFileSync('/tmp/express_debug.log', `${new Date().toISOString()} - ${req.method} ${req.url}\n`);
    next();
});

// Session configuration
app.use(session({
    store: new SQLiteStore({
        db: 'sessions.db',
        dir: '.',
        table: 'sessions'
    }),
    secret: 'pizza-system-secret-key-2024',
    resave: false,
    saveUninitialized: false,
    cookie: {
        secure: false, // Set to true in production with HTTPS
        httpOnly: true,
        maxAge: 24 * 60 * 60 * 1000 // 24 hours
    }
}));

// User context middleware for operations logging
app.use(userContextMiddleware);

// ================================
// DATABASE INITIALIZATION
// ================================
let productQueries, productionQueries, writeoffQueries, clientQueries, orderQueries, movementsQueries, batchQueries, arrivalQueries, initDatabase;
let userQueries, sessionQueries, auditQueries;
// Import mock userQueries
const { userQueries: mockUserQueries } = require("./queries/user-queries-mock");
userQueries = mockUserQueries;
let OperationsLogController;

try {
    console.log('[DB LOG] ะกะฟัะพะฑะฐ ะทะฐะฒะฐะฝัะฐะถะธัะธ ./supabase-database.js');
    const database = require('./supabase-database');
    console.log('[DB LOG] ะะพะดัะปั supabase-database.js ะทะฐะฒะฐะฝัะฐะถะตะฝะพ ััะฟััะฝะพ.');

    productQueries = database.productQueries;
    productionQueries = database.productionQueries || null;
    writeoffQueries = database.writeoffQueries || null;
    clientQueries = database.clientQueries || null;
    orderQueries = database.orderQueries || null;
    movementsQueries = database.movementsQueries || null;
    batchQueries = database.batchQueries || null;
    arrivalQueries = database.arrivalQueries || null;
    // userQueries = database.userQueries || null; // Keep mock version
    sessionQueries = database.sessionQueries || null;
    auditQueries = database.auditQueries || null;
    initDatabase = database.initDatabase;
    
    console.log("๐ Using mock Supabase - initializing AuthService directly...");
    
    // Initialize AuthService immediately for mock
        // authService already initialized with mock queries - SKIP
    
    console.log("โ Mock AuthService initialized");
    
    // Operations Log Controller
    OperationsLogController = require('./controllers/operations-log-controller');
    
    if (typeof initDatabase !== 'function') {
        console.error('[DB LOG] FATAL: initDatabase ะฝะต ั ััะฝะบัััั!');
        throw new Error('ะะพะผะธะปะบะฐ ัะฝัััะฐะปัะทะฐััั ะะ: ััะฝะบััั ะฝะต ะทะฝะฐะนะดะตะฝะฐ.');
    }

    console.log("๐ Attempting to initialize database...");
    // ะะฝัััะฐะปัะทััะผะพ ะฑะฐะทั ะดะฐะฝะธั
    initDatabase().then(() => {
        console.log('๐ ะะฐะทะฐ ะดะฐะฝะธั ะณะพัะพะฒะฐ ะดะพ ัะพะฑะพัะธ');
        console.log("โ Database initialized successfully, initializing services...");
        
        // ะะฝัััะฐะปัะทััะผะพ ัะตัะฒััะธ ะท ะทะฐะปะตะถะฝะพัััะผะธ
        productService.initialize({
            productQueries,
            OperationsLogController
        });
        
        clientService.initialize({
            clientQueries,
            OperationsLogController
        });
        
        orderService.initialize({
            orderQueries,
            productQueries,
            clientQueries,
            batchQueries,
            OperationsLogController
        });
        
        productionService.initialize({
            productionQueries,
            productQueries,
            OperationsLogController
        });
        
        writeoffService.initialize({
            writeoffQueries,
            productQueries,
            OperationsLogController
        });
        
        movementService.initialize({
            movementsQueries,
            productQueries,
            OperationsLogController
        });
        
        arrivalService.initialize({
            arrivalQueries,
            productQueries,
            OperationsLogController
        });
        
        // ะะฝัััะฐะปัะทััะผะพ AuthService ะท ะทะฐะปะตะถะฝะพัััะผะธ
        authService.initialize({
            userQueries,
            sessionQueries,
            auditQueries
        });
        
        // ะะฝัััะฐะปัะทััะผะพ Permission Service
        permissionService.initialize();
        
        // ะะฝัััะฐะปัะทััะผะพ User Service
        userService.initialize({
            userQueries,
            auditQueries
        });
        
        // ะะฝัััะฐะปัะทััะผะพ PDF ัะพััะธ
        initPdfRoutes({
            orderQueries,
            productQueries
        });
        
        console.log('โ ะกะตัะฒััะธ ัะฝัััะฐะปัะทะพะฒะฐะฝะพ');
        
        // ================================
        // MOUNT ROUTES AFTER SERVICE INITIALIZATION
        // ================================
        console.log('๐ง Mounting routes...');
        app.use('/api', productsRouter);
        console.log('โ Products router mounted');
        app.use('/api/auth', authRoutes);
        console.log('โ Auth router mounted');

        // Test route ะดะปั ะดัะฐะณะฝะพััะธะบะธ - ะฟะพะทะฐ auth ะฟัะพััะพัะพะผ
        app.get('/api/test-auth', (req, res) => {
            res.json({ message: 'Test route working!', auth_service: typeof authService, timestamp: new Date().toISOString() });
        });
        app.use('/api/users', userRoutes);
        console.log('โ Users router mounted');
        app.use('/api/clients', clientRoutes);
        console.log('โ Clients router mounted');
        app.use('/api/orders', orderRoutes);
        console.log('โ Orders router mounted');
        app.use('/api/production', productionRoutes);
        console.log('โ Production router mounted');
        app.use('/api/writeoffs', writeoffRoutes);
        console.log('โ Writeoffs router mounted');
        app.use('/api/movements', movementRoutes);
        console.log('โ Movements router mounted');
        app.use('/api/arrivals', arrivalRoutes);
        console.log('โ Arrivals router mounted');
        app.use(orderDocxRouter);
        app.use('/api', orderPdfRouter);
        app.use('/api', batchRoutes);
        
        // ะะพะฒั writeoff ัะพััะธ
        app.use('/api', newWriteoffRoutes);
        console.log('โ New Writeoff routes ะฟัะดะบะปััะตะฝะพ');
        
        // ะะพะดะฐัะบะพะฒั ะฟััะผั ัะพััะธ ะดะปั ัะตัััะฒะฐะฝะฝั
        const NewWriteoffController = require('./controllers/new-writeoff-controller');
        app.post('/api/new-writeoff', NewWriteoffController.createWriteoff);
        app.get('/api/writeoff-status', NewWriteoffController.getWriteoffStatus);
        console.log('โ ะััะผั writeoff ัะพััะธ ะดะพะดะฐะฝะพ');
        
        app.use('/api/operations', operationsLogRoutes);
        console.log('โ ะัั ัะพััะธ ะฟัะดะบะปััะตะฝะพ');
        
        // ================================
        // ERROR HANDLING - AFTER ROUTES
        // ================================
        app.use(notFoundHandler);
        app.use(globalErrorHandler);
        console.log('โ Error handlers ะฟัะดะบะปััะตะฝะพ');
        
        // ================================
        // SERVER STARTUP AFTER FULL INITIALIZATION
        // ================================
        app.listen(PORT, '0.0.0.0', () => {
            console.log(`๐ Pizza Inventory API (Modular) ะทะฐะฟััะตะฝะพ ะฝะฐ ะฟะพััั ${PORT}`);
            console.log(`๐ ะะพัััะฟะฝะธะน ะทะฐ ะฐะดัะตัะพั: http://116.203.116.234:${PORT}`);
            console.log(`๐ API ะดะพะบัะผะตะฝัะฐััั: http://116.203.116.234:${PORT}/api`);
            console.log(`๐๏ธ ะััััะตะบัััะฐ: Router + Service + Validator Pattern`);
            console.log(`๐ฆ ะะฐะฒะตััะตะฝั ะผะพะดัะปั: Auth, Users, Products, Clients, Orders, Production, Writeoffs, Movements, Arrivals (9/9 - 100%)`);
            console.log(`โ ะกะธััะตะผะฐ ะฐะฒัะพัะธะทะฐััั ัะฐ ะบะพัะธัััะฒะฐััะฒ ะณะพัะพะฒะฐ!`);
            console.log(`๐ฏ PHASE 1 COMPLETE: Arrivals module ะฒัะดะฝะพะฒะปะตะฝะพ!`);
        });
    }).catch(err => {
        console.error('โ ะะพะผะธะปะบะฐ ัะฝัััะฐะปัะทะฐััั ะะ:', err);
    });
} catch (error) {
    console.error('--- FATAL ERROR ON DATABASE LOAD ---');
    console.error(error);
    // Fallback ะดะพ null
    productQueries = null;
    productionQueries = null;
    writeoffQueries = null;
    clientQueries = null;
    orderQueries = null;
    movementsQueries = null;
    batchQueries = null;
    arrivalQueries = null;
    userQueries = null;
    sessionQueries = null;
    auditQueries = null;
}

// ================================
// API ROUTES
// ================================

// ะะพะปะพะฒะฝะฐ ััะพััะฝะบะฐ - ะฟะตัะตะฝะฐะฟัะฐะฒะปะตะฝะฝั ะฝะฐ index.html
app.get('/', (req, res) => {
    res.redirect('/index.html');
});

// API info endpoint
app.get('/api', (req, res) => {
    res.json({ 
        message: 'Pizza Inventory System API - Modular Architecture',
        version: '4.0.0',
        endpoints: {
            // Authentication Module
            authUsers: 'GET /api/auth/users',
            login: 'POST /api/auth/login',
            logout: 'POST /api/auth/logout',
            setPassword: 'POST /api/auth/set-password',
            changePassword: 'POST /api/auth/change-password',
            validateSession: 'GET /api/auth/validate',
            currentUser: 'GET /api/auth/me',
            
            // Users Module
            users: 'GET /api/users',
            createUser: 'POST /api/users',
            updateUser: 'PUT /api/users/:id',
            deleteUser: 'DELETE /api/users/:id',
            userRoles: 'GET /api/users/roles',
            userPermissions: 'GET /api/users/permissions',
            userStats: 'GET /api/users/stats',
            
            // Products Module
            products: 'GET /api/products',
            createProduct: 'POST /api/products',
            updateProduct: 'PUT /api/products/:id',
            deleteProduct: 'DELETE /api/products/:id',
            updateStock: 'POST /api/products/:id/stock',
            pizzas: 'GET /api/pizzas',
            stats: 'GET /api/stats',
            
            // Clients Module
            clients: 'GET /api/clients',
            createClient: 'POST /api/clients',
            updateClient: 'PUT /api/clients/:id',
            deleteClient: 'DELETE /api/clients/:id',
            
            // Orders Module
            orders: 'GET /api/orders',
            createOrder: 'POST /api/orders',
            orderById: 'GET /api/orders/:id',
            updateOrder: 'PUT /api/orders/:id',
            deleteOrder: 'DELETE /api/orders/:id',
            
            // Production Module
            production: 'GET /api/production',
            addProduction: 'POST /api/production',
            updateProduction: 'PUT /api/production/:id',
            deleteProduction: 'DELETE /api/production/:id',
            productionStatistics: 'GET /api/production/statistics',
            
            // Writeoffs Module
            writeoffs: 'GET /api/writeoffs',
            addWriteoff: 'POST /api/writeoffs',
            writeoffsByProduct: 'GET /api/writeoffs/product/:id',
            writeoffStatistics: 'GET /api/writeoffs/statistics',
            
            // Movements Module
            movements: 'GET /api/movements',
            createMovement: 'POST /api/movements',
            updateMovement: 'PUT /api/movements/:id',
            deleteMovement: 'DELETE /api/movements/:id?confirm=true',
            movementsByProduct: 'GET /api/movements/product/:id',
            movementStatistics: 'GET /api/movements/statistics',
            movementTypes: 'GET /api/movements/types',
            movementSummary: 'GET /api/movements/summary',
            
            // Arrivals Module
            arrivals: 'GET /api/arrivals',
            createArrival: 'POST /api/arrivals',
            arrivalById: 'GET /api/arrivals/:id'
        },
        architecture: 'Router + Service + Validator Pattern',
        modules: {
            completed: ['Auth', 'Users', 'Products', 'Clients', 'Orders', 'Production', 'Writeoffs', 'Movements', 'Arrivals'],
            total: 9,
            completion: '100%'
        },
        timestamp: new Date().toISOString()
    });
});

// Mount routes - ALL ROUTES WILL BE MOUNTED AFTER SERVICE INITIALIZATION

// ================================
// LEGACY ENDPOINTS (TEMPORARY)
// ================================

// Legacy endpoint for backward compatibility (ััะฐัะธะน ัะพัะผะฐั)
app.get('/api/pizzas', async (req, res, next) => {
    try {
        const products = await productService.getAllProducts();
        // ะะพะฒะตััะฐัะผะพ ั ััะฐัะพะผั ัะพัะผะฐัั (ะฟัะพััะธะน ะผะฐัะธะฒ)
        res.json(products);
    } catch (error) {
        next(error);
    }
});

// Stats endpoint ะดะปั compatibility
app.get('/api/stats', async (req, res, next) => {
    try {
        if (!productQueries) {
            return res.status(503).json({ error: 'ะะฐะทะฐ ะดะฐะฝะธั ะฝะตะดะพัััะฟะฝะฐ' });
        }
        
        const products = await productQueries.getAll();
        
        const stats = {
            total_products: products.length,
            total_stock_pieces: products.reduce((sum, p) => sum + (p.stock_pieces || 0), 0),
            total_stock_boxes: products.reduce((sum, p) => sum + (p.stock_boxes || 0), 0),
            low_stock_count: products.filter(p => (p.stock_pieces || 0) <= (p.min_stock_pieces || 0)).length
        };
        
        res.json(stats);
    } catch (error) {
        next(error);
    }
});

// ================================
// ERROR HANDLING - MOVED TO ASYNC BLOCK
// ================================
// Error handlers are now mounted after routes in the async initialization block

// ================================
// ERROR HANDLING FOR UNCAUGHT EXCEPTIONS
// ================================
process.on('uncaughtException', (error) => {
    console.error('โ UNCAUGHT EXCEPTION:', error);
    console.error('Stack:', error.stack);
    process.exit(1);
});

process.on('unhandledRejection', (reason, promise) => {
    console.error('โ UNHANDLED REJECTION at:', promise, 'reason:', reason);
    console.error('Stack:', reason?.stack);
    process.exit(1);
});

// ================================
// SERVER STARTUP - MOVED TO AFTER SERVICE INITIALIZATION
// ================================
// Server will start after services are initialized in the async block 